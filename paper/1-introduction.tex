\section{Introduction}

Formal verification is a subject that constantly attracts a great deal of attention from the research community. Static type systems are considered to be a lightweight verification method but they can be very powerful and precise as well. Dependent type systems in languages like Agda~\cite{Nor07}, Idris~\cite{Bra13} or Coq~\cite{coq} have been succesfully applied in practical verification tasks. But these languages are mostly receiveing attention from the research community and not from the industry.

Two things motivted me to write this paper. Firstly, while there are many tutorials on dependently typed programming and basics of verification, I could find little material demonstrating how to put verification to practical use. A must-read introductory level paper ``Why Dependent Types Matter'' by Altenkirch, McKinna and McBride \cite{AltMcBMcK05} that demonstrates how to use power of dependent types to prove correctness of merge sort algorithm actually elides many proof details that are required in a real-world application. I wanted to fill in that missing gap and write a tutorial that picks up where other tutorials have left. My second motivation came from reading Okasaki's classical ``Purely Functional Data Structures''~\cite{Oka99}. Despite book's title many presented implementations are not purely functional as they make use of impure exceptions to handle incorrect input. I realized that using dependent types allows to do better and it will be instructive to build a provably correct purely functional data structure on top of Okasaki's presentation. In the end this paper is not only a tutorial but also a case study of a weight biased leftist heap implemented in a dependently typed setting.

% goal - understanding

\subsection{Companion code}

This tutorial comes with companion code available at my web page \cite{js-webhome}. Code is written in Agda 2.3.3, which is a development version of the compiler as of January 2014. See Agda Wiki \cite{agda-wiki} for instructions how to install development version of Agda. I assume that the reader is reading the companion code along with the paper. Due to space limitations I elide some proofs that are described in detail in the companion code. ``Living'' version of companion code is available at GitHub \cite{js-github}. This version may receive updates after the paper has been published.

\subsection{Assumptions}

I assume that reader has basic understanding of Agda and using dependent types to conduct proofs. In particular I assume that reader is familiar with definition of natural numbers (\texttt{Nat}s) and their addition (\texttt{+}) as well as proofs of basic properties of addition like associativity, commutativity or 0 as right identity ($a + 0 â‰¡ a$). Reader should also understand \texttt{refl} with its basic properties (symmetry, congruence, transitivity and substitution), know the concept of ``data as evidence'' and other ideas presented in ``Why Dependent Types Matter'' \cite{AltMcBMcK05} as we will build upon them. If you are not familiar with some of the concepts listed above I recommend taking a look at tutorial papers listed on Agda Wiki \cite{agda-wiki}.

\subsection{Notation}

In the rest of the paper I use \texttt{typewriter font} to denote a heap and \textit{italic type} to denote its rank. The description of merge algorithm will mention heaps \texttt{h1} and \texttt{h2} with ranks \textit{h1} and \textit{h2}, respectively, their left children (\texttt{l1} in \texttt{h1} and \texttt{l2} in \texttt{h2}) and right children (\texttt{r1} in \texttt{h1} and \texttt{r2} in \texttt{h2}). \texttt{p1} and \texttt{p2} are the priorities of root elements in \texttt{h1} and \texttt{h2}, respectively. I will use $\oplus$ to denote heap merging operation. So \texttt{h1}$\oplus$\texttt{h2} is a heap created by merging \texttt{h1} with \texttt{h2}, while \textit{h1}$\oplus$\textit{h2} is the rank of merged heap.

In the text I will use numerals to represent \texttt{Nat}s, although in code I use encoding based on \texttt{zero} and \texttt{suc}. Thus 2 in the text corresponds to \texttt{suc (suc zero)} in the source code. I use \texttt{\hilight{\{ \}?}} in code listings to represent Agda holes.

\subsection{Contributions}

This paper contributes the following:

\begin{itemize}
 \item Section~\ref{sec:no-proofs} presents the problem of partiality of functions operating on a weight biased leftist heap. While the problem in general is well-known the solution to this particular case can be combined with verification of data structure's invariants. This is done in Section~\ref{sec:rank-property}.
 \item Section~\ref{sec:eq-proofs-using-trans} outlines a technique for constructing equality proofs using transitivity of propositional equality. This simple, stand-alone technique provides ground for understanding Agda's standard library.
 \item Section~\ref{sec:single-pass-merge-proof-by-comp} shows how composition of functions can be proved by composing their proofs.
 \item Section~\ref{sec:priority-invariant} examines the design decissions behind weight biased leftist heap API in presence of verification of priority property.
\end{itemize}
